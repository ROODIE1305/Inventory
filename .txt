whats the difference between
 app.baseURL = 'http://localhost:8080/'(spark serve)
 
  app.baseURL = 'http://localhost/inventory_management/public/'(xampp route)
 i can see codeigniter on both url

üîπ 1. http://localhost:8080/ (when you run php spark serve)

This uses PHP‚Äôs built-in development server.

CodeIgniter boots directly, no need for Apache/Nginx.

It ignores your XAMPP Apache ‚Äî so even if Apache is off, this still works.

Default port is 8080 (you can change with php spark serve --port 9000).

Good for development/testing, since it auto-detects changes and has cleaner error messages.

‚úÖ Pros:

Easier setup, no Apache config.

Developer-friendly error pages.

‚ùå Cons:

Not meant for production (slower, single-threaded).

üîπ 2. http://localhost/inventory_management/public/ (XAMPP Apache route)

This runs your app through Apache in XAMPP.

Apache serves your project like a real webserver would.

Requires your project folder (inventory_management) inside htdocs/.

Access is through /public/ (since CodeIgniter‚Äôs public/index.php is the front controller).

‚úÖ Pros:

Mimics how you‚Äôll run it on a real server.

Faster than PHP‚Äôs built-in server.

‚ùå Cons:

Slightly more setup (needs Apache running).

Errors may be less developer-friendly.

üîπ Which one should you use?

For learning & localhost development ‚Üí use php spark serve (http://localhost:8080/).

For testing like a real server (preparing for deployment) ‚Üí use XAMPP Apache route (http://localhost/inventory_management/public/).

Both will run the same app ‚Äî just different ways of serving it.

for creating FK
ALTER TABLE `orders` 
ADD CONSTRAINT `fk_orders_products` 
FOREIGN KEY (`product_id`)
REFERENCES `products`(`id`) 
ON DELETE CASCADE 
ON UPDATE CASCADE;

now again if someone asksme the mistake that i did earlier like he asks
what is the difference between if you create order id in customers table 
and customer id in orders table? 
what is the best approach and why

---->
‚ùå Case 1: order_id inside customers table

Structure:

customers: id, name, email, order_id (FK to orders)
orders: id, product_id, quantity, total


Meaning:

Each customer can only reference one order.

If the customer places a second order, 
there‚Äôs no way to store it (unless you overwrite the old one).

Problem:

Breaks real-world scenario where 
one customer can place multiple orders.

Violates 1-to-many relationship principle.

Very hard to scale for real businesses.

‚úÖ Case 2: customer_id inside orders table 
(best practice)

Structure:

customers: id, name, email, phone
orders: id, customer_id (FK to customers), product_id, total


Meaning:

Each order belongs to one customer.

One customer can place many orders (1-to-many).

Benefit:

Matches real-world: Customers can make 
multiple purchases.

Easy queries: ‚ÄúShow all orders of 
Customer X‚Äù ‚Üí simple JOIN.

Scalable: Works for 10 orders or 10 million.

Normalized (no duplicate customer data).

üîë Key Difference

Order ID in customers ‚Üí One-to-One 
(or ‚Äúone customer, one order‚Äù) ‚Üí Not practical.

Customer ID in orders ‚Üí One-to-Many 
(one customer, many orders) ‚Üí Correct relational design.

‚úÖ Final Answer (what you should say if asked)

If we put order_id in the customers table, 
we are forcing each customer to have only one order, 
which is not realistic in real-world systems. 
A customer usually places multiple orders, 
so the better approach is to put customer_id 
in the orders table. This way, we establish 
a one-to-many relationship: one customer 
can have many orders, but each order always 
belongs to one customer. It makes queries easier, 
ensures scalability, and follows proper 
database normalization.


//////////////////////////////
‚öôÔ∏è Relationships:

Each order can have one shipment record 
(or more if you allow partial shipments).

order_id in shipments will be a 
foreign key referencing orders.id.


//////////////////////////////////
‚úÖ Yes, that‚Äôs the correct way to add the foreign key for shipments.

So the flow is:

First create the shipments table (without the FK):

CREATE TABLE shipments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    status ENUM('Pending','In Transit','Delivered','Cancelled') DEFAULT 'Pending',
    shipped_date DATETIME NULL,
    delivered_date DATETIME NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


Then run your ALTER command to link it with orders:

ALTER TABLE shipments 
ADD CONSTRAINT fk_shipments_orders 
FOREIGN KEY (order_id) REFERENCES orders(id) 
ON DELETE CASCADE 
ON UPDATE CASCADE;

üîç How to check if it worked

Run this in SQL tab:

SHOW CREATE TABLE shipments;


You should see something like:

CONSTRAINT `fk_shipments_orders` FOREIGN KEY (`order_id`) REFERENCES `orders` (`id`)

/////////////Multiple shipments for one order////////////////
üöö Alternative Design (Multiple Shipments per Order)

In real-world e-commerce (Amazon, Flipkart, etc.), 
sometimes an order is shipped in parts:

Example: You order 3 items.

Item A arrives today, Item B tomorrow, 
Item C next week.

That means 1 order ‚Üí 3 shipments.

To support this, you‚Äôd still keep 
order_id in shipments, but allow multiple rows 
for the same order_id.

Order #10 ‚Üí Shipment #1 (Item A, Delivered)

Order #10 ‚Üí Shipment #2 (Item B, In Transit)

Order #10 ‚Üí Shipment #3 (Item C, Pending)

This changes the relationship to one-to-many:

One order can have many shipments.

//how the shipments table changes if you decide 
to support multiple shipments per order?//

‚úÖ What you have right now

orders (1) ‚Üí shipments (1)

Means: One order = One shipment record

Works fine for a basic system or small-scale use case.

üîÑ If later (or if interviewer asks for multiple shipments per order)

Change relationship to one-to-many: One order = Many shipments.

Keep the same shipments table, 
but allow multiple rows with the same order_id.

You just need to add more detail columns to differentiate shipments, e.g.:

CREATE TABLE shipments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    item_id INT NULL, -- optional, if shipping items separately
    status ENUM('Pending','In Transit','Delivered','Cancelled') DEFAULT 'Pending',
    shipped_date DATETIME NULL,
    delivered_date DATETIME NULL,
    FOREIGN KEY (order_id) REFERENCES orders(id)
        ON DELETE CASCADE ON UPDATE CASCADE
);


Example:

Order #5 ‚Üí Shipment 1 (shipped today)

Order #5 ‚Üí Shipment 2 (shipped tomorrow)

‚úÖ How to explain in an interview

‚ÄúCurrently, I designed shipments as one-to-one with orders, 
because in my system each order is shipped in one batch. 
But in a real-world e-commerce scenario, 
an order may have multiple shipments 
due to partial deliveries. To handle that, 
I would allow multiple rows in the shipments table 
for the same order_id, making it a one-to-many relationship. 
This makes the system more flexible and closer to real-world logistics.‚Äù